## [Main title](../README.md)
### [Interview questions](full.md)
# Python

## Оглавление
- [1. Виды типизации?](#1-Виды типизации)
- [2. Какой вид типизации в Python?](#2-Какой вид типизации в Python)
- [3. Что такое переменная?](#3-Что такое переменная)
- [4. Числа в Python]()
- [5. Строки в Python](https://github.com/markdrrr/interview_questions_python_junior/blob/main/README.md#5-строки-в-python)
- [6. Списки и кортежи в Python. В чем их отличие?](https://github.com/markdrrr/interview_questions_python_junior/blob/main/README.md#5-строки-в-python)
- [7. Словарь в python](https://github.com/markdrrr/interview_questions_python_junior/blob/main/README.md#7-cловарь-в-python)

## 1. Виды типизации

### По моменту проверки типов
 - **Статическая** - типизация, при которой переменная связывается с типом в момент объявления, и тип не может быть изменён позже. Пример статической типизации (С++):
```
int x = 5;
x = "abc";  // здесь C++ компилятор будет ругаться
```
или, что то же самое:
```
int x;
x = 5;
x = "abc"; // здесь C++ компилятор будет ругаться
```

- **Динамическая** - типизация, при которой тип переменной задается в момент присваивания значения, а не в момент объявления, и т.о. может быть изменен позже.
Пример динамической типизации (Python):
```
x = 5
x = "a"  # здесь интерпретатор не ругается, так как типизация динамическая
```

### По строгости контроля
- **Строгая** - отсутствие автоматических кастов в другой тип (неявных преборазований). Пример строгой типизации (Python):
```
a = [5, 6]
print(",".join(a))  # здесь интерпретатор ругается, так как join() ожидает список строк на входе
```
- **Нестрогая** - язык допускает автоматические преобразования типов. Пример нестрогой типизации (Javascript):
```
let a = "hello";
let b = 100;
let c = a + b;
console.log(c);  // "hello100"
```
### По изменяемости типов
- **Явная** - указываем типы везде руками. Пример явной типизации (C++):
```
int x = 5;
y = 6;  // здесь компилятор будет ругаться
```
- **Неявная** - язык сам определяет тип на основе значения. Пример неявной типизации (Python):
```
a = 1
```
**Важно**: наиболее рационально и оптимально память используется в случае строгой статической типизации.

## 2. Какой вид типизации в Python ?

Динамическая, строгая, неявная.

## 3. Что такое переменная
Переменная Python — это идентификатор для ссылки на объект в памяти программы. На один и тот же объект в памяти могут указывать (ссылаться) несколько переменных. Как только на область памяти перестают ссылаться переменные - данная область очищается сборщиком мусора, и т.о. память освобождается за счет подсчитывания ссылок на объекты в памяти.

## 4. Числа в Python
- int - целые числа.
- float - вещественные или действительные числа(числа с плавающей точкой).
- complex - комплексные числа.
- decimal - десятичные дроби.

## 5. Строки в Python
Cтрока – это упорядоченная последовательность символов, которая предназначена для хранения информации в виде простого текста. В Python3 строка по умолчнанию имеет кодировку Unicode, что избавляет от проблем работы и отображения символов кирилицы и прочих экзотических кодировок. Строка это неизменяемый тип данных, т.е. если нужно добавить символов в существующую строку, придется создать новую строку, с новым адресом в памяти:
```
a = "hello"
id(a) # 2044344987401
a = "hello world"
id(a) # 2044334957804
```
## 6. Списки (lists) и кортежи (tuples) в Python. В чем их отличие ?
Списки Python схожи с массивами в других языках. Кортеж похож на список, но вы создаете его с круглыми скобками, вместо квадратных. Вы также можете использовать встроенный инструмент для создания кортежей. Разница между списками и кортежами в том, что кортеж неизменяем, в то время как список изменяем. Т.е. в список можно добавить элемент и его адрес в памяти не изменится, а если нужно добавить элемент в кортеж, то нужно создать новый кортеж, и у него уже будет новый адрес в памяти:
```
# список
a = [1,2]
id(a) # 2044364987904
a.append(3)
id(a) # 2044364987904

# кортеж
a = (1,2)
id(a) # 2044370285184
a = (1,2,3)
id(a) # 2044369999872
```
**Важно**: кортеж занимает меньше места в памяти чем список, и поэтому всегда, когда массив объектов заведомо неизменяем, рекомендуется использовать кортежи, вместо списков.

## 7. Cловарь в Python
Словари в Python - коллекции произвольных объектов с доступом по ключу. Начиная с Python3.6 словарь dict() упорядочен, т.е. при переборе имеющегося словаря, элементы возвращаются в том порядке, в котором они были добавлены в словарь при его наполнении. До Python3.6 приходилось использовать объект OrderedDict(), чтобы иметь упорядоченную коллекцию, с доступам к элементам по ключам. Словарь это изменяемый тип данных.

## 8. Что такое итерация
Переход к следующему объекту в коллекции, например список, кортеж и т.д. Сам по себе объект коллекции должен быть iterable.

## 9. Какие циклы есть в python
`while` и `for`.

## 10. Чем отличается while от for
**For** используется только тогда, когда необходимо совершить перебор элементов заранее известное число раз. Цикл **while** также используется для повторения частей кода, но вместо зацикливания на **n** количество раз, он выполняет работу до тех пор, пока не достигнет определенного условия. Выйти из цикла в любой момент можно используя ключевое слово `break`, а перейти на следующую итерацию цикла можно используя слово `continue`.

## 11. Преобразование типов
- Преобразование типов - это преобразование объекта из одного типа данных в другой тип данных.
- Неявное преобразование типов автоматически выполняется интерпретатором Python.
- Python позволяет избежать потери данных в неявном преобразовании типов.
- Явное преобразование типов также называется приведением типов, типы данных объекта преобразуются с использованием предопределенной функции.
- При приведении типов может произойти потеря данных, поскольку мы приводим объект к определенному типу данных.

## 12. Что такое аннотация типов
В простейшем случае аннотация содержит непосредственно ожидаемый тип. Аннотации для переменных пишут через двоеточие после идентификатора. После этого может идти инициализация значения. Например `price: int = 5`
Параметры функции аннотируются так же как переменные, а возвращаемое значение указывается после стрелки `->` и до завершающего двоеточия. Например
`def indent_right(s: str, width: int) -> str:`.

**Важно**: аннотация типов не есть то же самое, что статическая типизация.

## 13. Что такое PEP
PEP - Python Enhancement Proposals - база всех предложений как улучшить Python и что изменить. Например PEP8 - это общепринятое руководство по написанию кода на Python.

## 14. Что такое фунция range
Функция `range()` возвращает объект с интерфейсом итератора, выдающий элементы из диапазона, определяемого аргументами функции range(старт, стоп, шаг), при этом не храня все элементы в памяти.

## 15. Что делает enumerate ?
Если начальное значение счётчика `enumerate()` не передаётся — оно, по умолчанию, устанавливается в 0. Функция создаёт объект, генерирующий кортежи, состоящие из индекса элемента и самого этого элемента.
### Пример
```python
    fruits = ["apple", "banana", "cherry"]

    # Пример 1: без указания начального значения
    for index, fruit in enumerate(fruits):
        print(index, fruit)
    
    # Вывод:
    # 0 apple
    # 1 banana
    # 2 cherry
    
    
    # Пример 2: с указанием начального значения счётчика
    for index, fruit in enumerate(fruits, start=1):
        print(index, fruit)
    
    # Вывод:
    # 1 apple
    # 2 banana
    # 3 cherry
```

## 16. Какие методы списков
- list.append(x) Добавляет элемент в конец списка
- list.extend(L) Расширяет список list, добавляя в конец все элементы списка L
- list.insert(i, x)	Вставляет на i-ый элемент значение x
- list.remove(x) Удаляет первый элемент в списке, имеющий значение x. ValueError, если такого элемента не существует
- list.pop([i])	Удаляет i-ый элемент и возвращает его. Если индекс не указан, удаляется последний элемент
- list.index(x, [start [, end]])	Возвращает положение первого элемента со значением x (при этом поиск ведется от start до end)
- list.count(x)	Возвращает количество элементов со значением x
- list.sort([key=функция])	Сортирует список на основе функции
- list.reverse() Разворачивает список
- list.copy()	Поверхностная копия списка
- list.clear() Очищает список

## 17. Что в python не является объектом
В python всё является объектом, кроме ключевых слов: in, is, if, while, и т.д.

## 18. Название переменных
Имя переменной может состоять только из цифр, букв и знаков подчеркивания. Имя переменной может начинаться только с буквы или с нижнего подчеркивания. Никаких чисел в начале имени переменной быть не должно.  Имя переменной не может содержать ключевые слова (зарезервированные) языка Python. Принято разделять слова нижним подчеркиванием (snake case).

## 19. Сколько пар ключ значение может быть в словаре
Ограничено объемом оперативной памяти.

## 20. Какой тип данных может быть значением в словаре
Ключом может являться в принципе любой неизменяемый тип данных.

## 21. Как узнать id элемента
Функция `id()` возвращает уникальный идентификатор для указанного объекта. По сути этот идентификатор однозначно опредедяет адрес объекта в памяти интерпретатора.

### Пример
- У разных объектов — разные id. Каждое значение хранится как отдельный объект, поэтому id у них разный.
```python
    a = 10
    b = 20
    
    print(id(a))  # например: 140713254780048
    print(id(b))  # например: 140713254780368
```
- У переменных с одинаковым значением может быть один id. Python оптимизирует хранение малых целых чисел (-5 … 256) и некоторых строк, поэтому такие объекты могут ссылаться на одну и ту же область памяти.
```python
    x = 1000
    y = 1000
    print(id(x))
    print(id(y))
    print(x is y)  # False (обычно разные объекты)
    
    x = 10
    y = 10
    print(id(x))
    print(id(y))
    print(x is y)  # True (малые целые числа интернированы)
```
- Проверка, что переменные указывают на один объект. Здесь a и b — это ссылки на один и тот же объект (список).
```python
    a = [1, 2, 3]
    b = a
    
    print(id(a))  # одинаковый id
    print(id(b))  # одинаковый id
    print(a is b) # True
```
- Создание копии. В этом случае b — это новый объект, поэтому у него другой id.
```python
    import copy

    a = [1, 2, 3]
    b = copy.copy(a)
    
    print(id(a))  # например: 2109987654320
    print(id(b))  # другой id
    print(a is b) # False
```
### Когда полезно использовать `id()`

- Чтобы понять, ссылаются ли переменные на один и тот же объект.
- Для отладки, когда нужно отследить, создаются ли новые объекты или переиспользуются старые.
- При работе с изменяемыми (`list`, `dict`, `set`) и неизменяемыми (`int`, `str`, `tuple`) объектами — удобно видеть, как Python управляет памятью.  

## 22. Что такое байт код ?
Python - интерпретируемый язык программирования. Он не конвертирует свой код в машинный, который понимает железо (в отличие от С и С++). Процесс такой вот конвертации называется компилляцией. Вместо этого, Python-интерпретатор, а точнее говоря его стандартная реализация CPython, переводит код программы в байт-код, который запускается на виртуальной машине Python (PVM). Есть реализация интерпретатора Python, которая работает через JIT (just in time) компилляцию - Pypy.

## 23. Что такое объектно-ориентированное программирование (ООП)? Назови основные принципы ООП

**Объектно-ориентированное программирование (ООП)** — это парадигма программирования, в которой программа строится вокруг объектов.  
**Объект** — это сущность, которая объединяет:
- **данные** (свойства, атрибуты),
- **методы** (поведение, функции).

### Основные принципы ООП

1. **Инкапсуляция**
    - Объединение данных и методов, работающих с ними, в единый объект.
    - Сокрытие внутренней реализации и предоставление внешнего интерфейса.
    - Пример: атрибуты `private`, доступ к ним через методы `get/set`.

2. **Наследование**
    - Возможность создавать новые классы на основе существующих.
    - Упрощает переиспользование кода.
    - Пример: класс `Student` наследует свойства и методы класса `Person`.

3. **Полиморфизм**
    - Возможность использовать один и тот же интерфейс для разных типов объектов.
    - Например, метод `draw()` может быть реализован по-разному в `Circle`, `Square`, `Triangle`.

4. **Абстракция**
    - Выделение главного и сокрытие лишнего.
    - Определение интерфейсов без реализации.
    - Пример: абстрактный класс `Shape` с методом `draw()`, который реализуют потомки.


### Пример
```python
    class Animal:
        def speak(self):
            raise NotImplementedError(“Этот метод нужно переопределить”)
    
    class Dog(Animal):
        def speak(self):
            return “Гав!”
    
    class Cat(Animal):
        def speak(self):
            return “Мяу!”
    
    animals = [Dog(), Cat()]
    for a in animals:
        print(a.speak())  # Полиморфизм: выводит “Гав!” и “Мяу!”
```

### Плюсы ООП
- Легче моделировать реальные сущности.
- Повторное использование кода через наследование.
- Гибкость и расширяемость системы.
- Инкапсуляция делает код более безопасным и понятным.

### Минусы ООП
- Может быть избыточным для простых задач.
- Более высокая сложность, чем у процедурного подхода.
- Иногда приводит к переусложнению архитектуры.

## 23. Что такое класс ?
Класс — тип, описывающий устройство объектов. Другими словами, это описание сущности, у которой есть определенный набор свойств и методов.

## 24. Сколько может быть родителей и наследников у класса
Неограниченное количество.

## 25. Разрешение зависимости

## 26. Что такое перегрузка операторов
Один из способов реализации полиморфизма, заключающийся в возможности одновременного существования в одной области видимости нескольких различных вариантов применения оператора, имеющих одно и то же имя, но различающихся типами параметров, к которым они применяются. Перегрузка операторов **не** поддерживается в Python.

Пример из C++, где поддерживается перегрузка операторов:
```
float getArea(float a, float b) // функция, вычисляющая площадь прямоугольника с длиной a и высотой b
{
  return a * b;
}

float getArea(float r) // функция, вычисляющая площадь круга с радиусом r
{
  return pi * r * r;
}

float S1 = getArea(5.0, 6.0); // 30
float S3 = getArea(5.0); // 78.5
```

## 27. Магические методы
Это специальные методы в python, обрамленные двумя нижними подчеркиваниями
- Инициализация объекта: `__init__`
- Строковые представления: `__repr__` , `__str__`
- Итерация: `__iter__` , `__next__` и другие

## 28. Модификаторы доступа
Есть три типа модификаторов доступов в Python ООП:
- публичный `public`
- приватный `__private`
- защищенный `_protected`

**Важно**: в Python нету жесткой инкапсуляции, т.е. даже к приватному методу можно получить доступ снаружи класса. Инкапсуляция в Python это больше договорянность между разработчиками, чем жесткое сокрытие, как например в C++ или Java.

## 29. Генераторы
Это функция, которая будучи вызванной в функции **next()** возвращает следующий объект согласно алгоритму ее работы. Вместо ключевого слова **return** в генераторе используется **yield**. Главное отличие yield от return это то, что yield, после возврата объекта, сохраняет стек генератора, так что при следующем вызове функции next() от генератора, исполнение кода генератора продолжится с того момента, где yield вернул объект в прошлый раз.

## 30. Comprehension

## 31. Расскажите про генераторы списков (list comprehension)
Генераторы позволяют создавать списки с помощью одной строки кода
```
>>> [i for i in range(1, 11, 2)]
[1, 3, 5, 7, 9] 
```

## 32. Что такое миксины
**Mixin** представляет собой набор свойств и методов, которые могут быть использованы в различных классах, которые не приходят из базового класса.

## 33. Звёздный синтаксис (Добавить пример)
- * и ** для передачи аргументов в функцию;
- * и **   для сбора переданных в функцию аргументов;
- ** для принятия только именованных аргументов;
-	* при распаковке кортежей;
- * для распаковки итерируемых объектов в список/кортеж;
-	** для распаковки словарей в другие словари.

## 34. Что такое GIL
Глобальная блокировка интерпретатора CPython. Это механизм, который не позволяет нескольким потокам выполнить один и тот же байткод. Другими словами, благодаря GIL, в каждый момент времени в контексте одного процесса Python исполняется только один поток (Thread), все остальные ждут своей очереди на исполнение. Именно поэтому многопоточность не ускоряет обработку данных в разных потоках, так как по факту все обрабатывается последовательно.

## 35. Принципы SOLID

S – Single Responsibility (Принцип единственной ответственности)

```Каждый класс должен отвечать только за одну операцию.```

O — Open-Closed (Принцип открытости-закрытости)

```Классы должны  быть  открыты для расширения, но закрыты для модификации.```

L — Liskov Substitution (Принцип подстановки Барбары Лисков)

```Если П является подтипом Т, то любые объекты типа Т, присутствующие в программе, могут заменяться объектами типа П без негативных последствий для функциональности программы.```

I — Interface Segregation (Принцип разделения интерфейсов)

```Не следует ставить клиент в зависимость от методов, которые он не использует.```

D — Dependency Inversion (Принцип инверсии зависимостей)

```Модули верхнего уровня не должны зависеть от модулей нижнего уровня. И те, и другие должны зависеть от абстракций. Абстракции не должны зависеть от деталей. Детали должны зависеть от абстракций.```

## 36. Можете объяснить жизненный цикл треда?

Общими словами, цикл выглядит так:
- сначала создается класс, который подменяет метод исполнения класса в треде, и создаем экземпляр (instance) для этого класса;
- вызываем start(), который готовит тред к исполнению;
- переводим тред в состояние исполнения;
- можно вызвать разные методы, например sleep() и join(), которые переводят тред в режим ожидания;
- когда режим ожидания или исполнения прекращается, другие ожидающие треды подготавливаются к исполнению;
- после завершения исполнения тред останавливается.

## 37. Что такое функция?

Когда мы хотим исполнить определенную последовательность (sequence of statements), мы можем дать ей имя. Например, определим функцию, которая принимает два числа и возвращает то, которое больше.

## 38. Что такое рекурсия?

Это когда функция вызывает саму себя. При этом она должна иметь базовое условие, чтобы не создать бесконечный цикл:

## 39. Что делает функция zip()?

Возвращает итератор с кортежами:

В данном случае она совмещает элементы двух списков и создает из них кортежи. Работает не только со списками.

## 40. Расскажите про try, raise и finally.

Это ключевые слова (keywords) для обработки исключений (exception handling). Потенциально рискованный код помещается в блок try, оператор raise (raise statement) используется для прямого вызова ошибки, а в блоке finally находится код, который исполняется в любом случае.

## 41. Что случится, если не обработать ошибку в блоке except?

Если этого не сделать, программа завершится. Затем она отправит трассу исполнения на sys.stderr.

## 42. Объясните разницу между полной копией (deep copy) и поверхностной копией (shallow copy).

Полное копирование создает новый объект-копию. То есть, если внести изменение в копию объекта, то с первоначальным объектом ничего не случится. В Python для этого используется функция deepcopy() с помощью импорта из модуля copy.

>>> import copy
>>> b=copy.deepcopy(a)
Поверхностная копия копирует на новый объект ту ссылку, которая закреплена на первоначальном объекте. Поэтому если внести изменение в копию, то оно распространится на первоначальный объект. Данный функционал реализуется с помощью функции copy().

>>> b=copy.copy(a)

## 43. Можно ли сказать, что массив (array) NumPy лучше списка (list)?

Массивы NumPy имеют три преимущества перед списками:

Они быстрее
Они потребляют меньше памяти
С ними удобнее работать

## 44. Можно ли осуществить динамическую загрузку модуля в Python?

При динамической загрузке модули загружаются только когда они становятся нужны. Такой подход — медленный, но он помогает эффективнее использовать память. В Python для этого можно использовать модуль importlib:

import importlib
module = importlib.import_module('my_package.my_module')

## 45. Какие методы/функции мы используем для определения типа экземпляра (type of instance) и наследования (inheritance)?

Для этого используются type(), isinstance() и issubclass().

1. type() используется для определени типа объекта.

>>> type(3)
>>> type(False)
>>> type(lambda :print("Hi"))
>>> type(type)
2. isinstance() принимает два аргумента: значение (value) и тип (type). Если значение относится к соответствующему типу, то возвращается True. Если нет, то возвращается False.

>>> isinstance(3,int)
True
>>> isinstance((1),tuple)
False
>>> isinstance((1,),tuple)
True
3. issubclass() принимает два класса (classes) в качестве аргументов (arguments). Если второй наследует из первого, то возвращается True. Если нет, то возвращается False.

>>> class A: pass
>t; class B(A): pass
>>> issubclass(B,A)
True
>>> issubclass(A,B)
False

## 46. Объясните, как в Python осуществляется управление памятью.

В Python объекты и структуры данных (data structures) находятся в закрытой динамически выделяемой области (private heap), которая управляется менеджером памяти Python. Он делегирует часть работы программам распределения ресурсов (allocators), закрепленным за конкретными объектами, и одновременно с этим следит, чтобы они не выходили за пределы динамически выделяемой области. По факту данной областью управляет интерпретатор (interpreter). Пользователь никак не контролирует данный процесс, даже когда манипулирует ссылками объектов на блоки памяти внутри динаической области. Менеджер памяти Python распределяет пространство динамической области среди объектов и другие внутренние буферы по требованию.

## 47. Что такое декоратор (decorator)?

Функция, которая расширяет другую функцию без внесения в нее изменений, оборачиваясь (wrap) вокруг нее. Посмотрим на примере.

>>> def decor(func):
....def wrap():
........print("$$$$$$$$$$$$$$$$$")
........func()
........print("$$$$$$$$$$$$$$$$$")
Декораторы — из сферы метапрограммирования (metaprogramming), в котором одна часть кода пытается изменить другую.

## 48. Назовите изменяемые и неизменяемые объекты
Неизменяемость означает, что состояние нельзя изменить после создания. Примеры: int, float, bool, string и tuple.

Состояние изменяемых объектов можно изменить. Примеры: list, dict и set.

## 49. Что такое ORM ?