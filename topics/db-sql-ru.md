## [Main title](../README.md)
### [Interview questions](full.md)
# DB/SQL

# 1. Что такое SQL и для чего он используется?

**SQL** (Structured Query Language — язык структурированных запросов) — это предметно-ориентированный декларативный язык программирования, предназначенный для работы с реляционными базами данных.  
Он является основным языком для выполнения таких задач, как:
- извлечение данных,
- изменение данных,
- администрирование базы данных.

## Основные компоненты SQL

- **DDL (Data Definition Language)** — язык определения данных. Используется для описания и изменения структуры базы данных.
- **DML (Data Manipulation Language)** — язык манипулирования данными. Отвечает за добавление, изменение и удаление данных в базе.
- **DCL (Data Control Language)** — язык управления доступом. Используется для управления правами и разрешениями в базе данных.
- **TCL (Transaction Control Language)** — язык управления транзакциями. Регулирует работу с транзакциями (например, фиксация изменений `COMMIT` или их откат `ROLLBACK`). 

# 2. Разница между SQL и NoSQL базами данных

SQL и NoSQL базы данных предлагают разные парадигмы, каждая из которых предназначена для определённых типов данных и способов их обработки.

## Основные различия

- **SQL**: Предназначены в первую очередь для структурированных (и частично полуструктурированных) данных, которые соответствуют заранее определённой схеме.
- **NoSQL**: Подходят для неструктурированных или полуструктурированных данных, которые постепенно эволюционируют, обеспечивая гибкость в схемах.

- **SQL**: Использует язык SQL (Structured Query Language) для модификации и извлечения данных.
- **NoSQL**: Предоставляет различные API (например, интерфейсы для документо-ориентированных и ключ-значение хранилищ); использование структурированных языков запросов зависит от конкретной реализации.

- **SQL**: Обычно гарантирует соответствие принципам **ACID** (атомарность, согласованность, изоляция, долговечность), что обеспечивает целостность данных.
- **NoSQL**: Часто оптимизированы для высокой производительности и горизонтального масштабирования, иногда в ущерб строгой согласованности.

## Основные типы NoSQL баз данных

- **Документо-ориентированные хранилища**
    - Примеры: MongoDB, Couchbase
    - Особенности: каждая запись — это самостоятельный документ (обычно JSON). Связи реализуются через вложенные документы или ссылки.
    - Пример: пользователь и его посты в блоге могут храниться в одном документе или быть связаны через ссылки.

- **Ключ-значение хранилища**
    - Примеры: Redis, Amazon DynamoDB
    - Особенности: данные хранятся в виде уникальных ключей и значений. Нет обязательной схемы.
    - Пример: товары в корзине интернет-магазина, связанные с ID пользователя.

- **Широкостолбцовые базы (Column Families)**
    - Примеры: Apache Cassandra, HBase
    - Особенности: данные группируются в семейства столбцов, аналогичные таблицам, но с гибкой схемой.
    - Пример: профили пользователей, где у одних могут быть уникальные атрибуты.

- **Графовые базы данных**
    - Примеры: Neo4j, JanusGraph
    - Особенности: оптимизированы для данных со сложными связями. Сущности представлены как узлы, а связи — как рёбра.
    - Пример: социальные сети с управлением связями «дружбы».

## Отличия в моделировании данных

- **SQL**: нормализация для минимизации избыточности и аномалий при обновлении.
- **NoSQL**: денормализация — данные упаковываются вместе, чтобы сократить количество запросов.

## Генерация ID

- **SQL**: часто используется автоинкрементное уникальное ID.
- **NoSQL**: уникальные идентификаторы могут генерироваться внешними системами или на уровне документа.

## Работа с отношениями данных

- **SQL**: связи реализуются через ключи (первичные и внешние).
- **NoSQL**: связи могут быть реализованы через вложенные документы, ссылки или графовые структуры.

## Поддержка транзакций

- **SQL**: транзакции — стандартная часть функционала.
- **NoSQL**: поддержка транзакций зависит от реализации.

## Уровни согласованности данных

- **SQL**: обеспечивает строгую согласованность.
- **NoSQL**: предлагает разные модели — от строгой до eventual consistency (согласованности в конечном счёте).

## Масштабируемость

- **SQL**: вертикальная (мощность одного сервера увеличивается).
- **NoSQL**: горизонтальная (распределение нагрузки на множество серверов).

## Гибкость данных

- **SQL**: строгая схема, трудно адаптировать к меняющимся структурам данных.
- **NoSQL**: поддерживает динамическое обновление схемы, что даёт высокую гибкость.

## Целостность и валидация данных

- **SQL**: целостность обеспечивается ограничениями и строгими типами данных.
- **NoSQL**: больше полагается на приложение для управления целостностью и проверкой данных.  

# 3. Какие операции можно выполнять с помощью SQL, для чего они нужны и их порядок выполнения?

В SQL команды делятся на несколько категорий.

## DDL (Data Definition Language) — язык определения данных
Используется для описания и изменения структуры объектов базы данных.

- **CREATE** — создание объектов (таблицы, представления, схемы и т.д.)
- **ALTER** — изменение структуры объектов
- **DROP** — удаление объектов
- **TRUNCATE** — очистка таблицы (быстрое удаление всех строк без возможности отката)
- **RENAME** — переименование объекта

> ⚡ Особенность: DDL-команды фиксируются автоматически (**auto-commit**) и не могут быть откатаны.

---

## DML (Data Manipulation Language) — язык манипуляции данными
Используется для работы с данными в таблицах.

- **SELECT** — чтение данных
- **INSERT** — добавление строк
- **UPDATE** — изменение строк
- **DELETE** — удаление строк

> ⚡ Особенность: DML-команды поддерживают транзакции и могут быть отменены (**ROLLBACK**).

### Основные операции в SELECT-запросе
- **SELECT** — определяет столбцы или выражения для вывода
- **FROM** — задаёт источники данных (таблицы, представления)
- **JOIN** — объединяет данные из разных таблиц
- **WHERE** — фильтрует строки до группировки
- **GROUP BY** — группирует строки в агрегаты
- **HAVING** — фильтрует сгруппированные результаты
- **ORDER BY** — сортирует вывод
- **LIMIT** — ограничивает количество возвращаемых строк

#### Логический порядок выполнения запроса
Хотя пишем мы команды в одном порядке, выполняются они так: FROM → JOIN → WHERE → GROUP BY → HAVING → SELECT → ORDER BY → LIMIT

> Это объясняет, например, почему нельзя использовать алиасы из `SELECT` в `WHERE`.

---

## DCL (Data Control Language) — язык управления доступом
Используется для работы с правами пользователей.

- **GRANT** — выдаёт права
- **REVOKE** — отзывает права

---

## TCL (Transaction Control Language) — язык управления транзакциями
Регулирует выполнение транзакций.

- **COMMIT** — зафиксировать изменения
- **ROLLBACK** — откатить изменения
- **SAVEPOINT** — установить точку сохранения в транзакции

---

📌 **Краткий итог:**
- DDL управляет структурой базы (CREATE/ALTER/DROP).
- DML управляет данными (SELECT/INSERT/UPDATE/DELETE).
- DCL управляет доступом (GRANT/REVOKE).
- TCL управляет транзакциями (COMMIT/ROLLBACK/SAVEPOINT).
- Логический порядок выполнения SELECT отличается от синтаксического и это важно для правильного понимания запросов.  

# 4. Какие типы JOIN-ов существуют и в чем их отличия ?

# JOIN в SQL и их типы

**JOIN** в SQL используется для объединения строк из двух или более таблиц на основе связанного столбца (обычно ключа).  
Понимание типов соединений важно для правильной работы с нормализованными данными и предотвращения случайных декартовых произведений.

## Основные типы JOIN

- **INNER JOIN** — возвращает только совпадающие строки в обеих таблицах.
- **LEFT JOIN** — возвращает все строки из левой таблицы и совпадения из правой; если совпадений нет, подставляются `NULL`.
- **RIGHT JOIN** — противоположен LEFT JOIN: возвращает все строки из правой таблицы и совпадения из левой.
- **FULL JOIN (FULL OUTER JOIN)** — возвращает все строки из обеих таблиц, подставляя `NULL` там, где нет совпадений.
- **CROSS JOIN** — формирует декартово произведение (каждая строка из первой таблицы соединяется со всеми строками второй).
- **SELF JOIN** — соединение таблицы с самой собой (часто используется для иерархий, например «сотрудник → менеджер»).

## Визуализация типов JOIN

![SQL JOINS](../images/sql-joins.png)

# 5. Что такое первичный ключ (Primary Key) в базе данных?

**Первичный ключ** — это столбец или набор столбцов, которые однозначно идентифицируют каждую строку в таблице базы данных.

## Основные свойства:
- Значения **должны быть уникальными**.
- Значения **не могут быть NULL**.
- В таблице может быть **только один первичный ключ**, но он может состоять из нескольких столбцов (**составной ключ**).
- Большинство СУБД автоматически создают индекс для первичного ключа, чтобы ускорить поиск.

## Пример

```sql
CREATE TABLE employees (
    employee_id INT PRIMARY KEY,
    name VARCHAR(100)
);
```
### Что делает этот код?

1. Создаёт таблицу `employees`.
2. Определяет столбец `employee_id` как **PRIMARY KEY**.
3. Обеспечивает уникальность каждого значения `employee_id`.
4. Запрещает использование `NULL` для `employee_id`.
5. Даёт возможность использовать `employee_id` как ссылку (внешний ключ) в других таблицах.
6. Автоматически создаёт индекс по `employee_id` для ускорения поиска. 

# 6. Что такое внешний ключ (Foreign Key) и как он используется?

**Внешний ключ (FOREIGN KEY)** — это столбец или набор столбцов в одной таблице, которые ссылаются на первичный ключ в другой таблице.

## Основные свойства:
- Внешний ключ всегда указывает на **PRIMARY KEY** или **UNIQUE ключ** в родительской таблице.
- Его назначение — обеспечивать **ссылочную целостность**, то есть согласованность связей между таблицами.
- Он не допускает вставку значений, которых нет в родительской таблице.
- Может определять действия при изменении или удалении строки в родительской таблице:
  - `ON DELETE CASCADE` — удаляет связанные записи.
  - `ON DELETE SET NULL` — устанавливает значение `NULL` во внешнем ключе.
  - `RESTRICT` — запрещает удаление/обновление, если есть связанные записи.

## Пример

```sql
CREATE TABLE employees (
    employee_id INT PRIMARY KEY,
    department_id INT,
    FOREIGN KEY (department_id) REFERENCES departments(department_id)
);
```

# 7. В чем разница между PRIMARY KEY и UNIQUE ключом?

## PRIMARY KEY
- Однозначно идентифицирует каждую строку в таблице.
- Может состоять из **одного или нескольких столбцов** (составной ключ).
- В таблице может быть **только один PRIMARY KEY**.
- Значения **не могут быть NULL**.
- При создании автоматически создаётся индекс.

## UNIQUE ключ
- Гарантирует, что значения в столбце (или наборе столбцов) будут уникальны.
- В таблице может быть **несколько UNIQUE ключей**.
- В отличие от PRIMARY KEY, допускает **одно значение NULL** (поведение может отличаться в разных СУБД).
- Тоже создаёт уникальный индекс, но не обязательно является «основным идентификатором» таблицы.

## Кратко
- `PRIMARY KEY` — главный идентификатор строки, обязателен для таблицы и всегда **NOT NULL + UNIQUE**.
- `UNIQUE` — дополнительное ограничение для предотвращения дубликатов в других столбцах, но допускает `NULL` (в большинстве СУБД).

## Пример

```sql
CREATE TABLE users (
    user_id INT PRIMARY KEY,
    email VARCHAR(255) UNIQUE,
    phone VARCHAR(20) UNIQUE
);
```

# 8. Какие виды связей между таблицами существуют и как они реализуются?

В реляционных базах данных существуют три основных типа связей между таблицами: **1:1 (один к одному)**, **1:M (один ко многим)** и **M:N (многие ко многим)**.

---

## 1. Связь 1:1 (One-to-One)

**Определение:** каждой записи в первой таблице соответствует не более одной записи во второй, и наоборот.

**Пример:**
- Таблица `users` — основная информация о пользователях.
- Таблица `user_profiles` — дополнительная информация (например, паспортные данные).

**Реализация:**  
Во второй таблице (`user_profiles`) создаётся внешний ключ (`FOREIGN KEY`), который также является `PRIMARY KEY`.  
Это гарантирует, что у каждого пользователя будет не более одного профиля.

```sql
CREATE TABLE users (  
  user_id INT PRIMARY KEY,  
  name VARCHAR(100)  
);

CREATE TABLE user_profiles (  
  user_id INT PRIMARY KEY,  
  address VARCHAR(200),  
  FOREIGN KEY (user_id) REFERENCES users(user_id)  
);
```

## 2. Связь 1:M (One-to-Many)

**Определение:** каждой записи в первой таблице может соответствовать много записей во второй, но каждая запись во второй таблице относится только к одной записи в первой.

**Пример:**
- Таблица `departments` — список отделов.
- Таблица `employees` — список сотрудников.

**Реализация:**  
Во второй таблице (`employees`) создаётся внешний ключ, который ссылается на первичный ключ первой таблицы (`departments`).

```sql
CREATE TABLE departments (  
  department_id INT PRIMARY KEY,  
  department_name VARCHAR(100)  
);

CREATE TABLE employees (  
  employee_id INT PRIMARY KEY,  
  name VARCHAR(100),  
  department_id INT,  
  FOREIGN KEY (department_id) REFERENCES departments(department_id)  
);
```

## 3. Связь M:N (Many-to-Many)

**Определение:** каждой записи в первой таблице может соответствовать много записей во второй, и наоборот.

**Пример:**
- Таблица `students` — студенты.
- Таблица `courses` — курсы.
- Один студент может посещать много курсов, и один курс может посещаться многими студентами.

**Реализация:**  
Создаётся третья таблица (промежуточная или связующая), которая хранит пары ключей.

```sql
CREATE TABLE students (  
  student_id INT PRIMARY KEY,  
  name VARCHAR(100)  
);

CREATE TABLE courses (  
  course_id INT PRIMARY KEY,  
  course_name VARCHAR(100)  
);

CREATE TABLE student_courses (  
  student_id INT,  
  course_id INT,  
  PRIMARY KEY (student_id, course_id),  
  FOREIGN KEY (student_id) REFERENCES students(student_id),  
  FOREIGN KEY (course_id) REFERENCES courses(course_id)  
);
```

Таблица `student_courses` связывает студентов и курсы, реализуя связь «многие ко многим».

# 9. Что такое нормализация? Объясните с примерами

**Нормализация** — это метод проектирования базы данных, направленный на упорядочение структуры таблиц с целью уменьшения избыточности данных и повышения их целостности.  
Процесс выполняется поэтапно и разделён на несколько нормальных форм (1NF, 2NF, 3NF, BCNF, 4NF), каждая из которых имеет свои правила.

## Пример нормализации (сценарий «Customer Invoices»)

### Ненормализованная таблица (0NF)

| ID | Name | Invoice No. | Invoice Date | Item No. | Description | Quantity | Unit Price |
|----|------|-------------|--------------|----------|-------------|----------|------------|

В таком виде все данные хранятся в одной таблице без структурной логики. Записи содержат и данные о клиенте, и данные о счёте, и данные о товарах. Это приводит к избыточности и аномалиям.

### Первая нормальная форма (1NF)

**Правило:** все ячейки должны быть атомарными (только одно значение). Нужно разделять связанные группы данных.

В примере выделяем отдельные таблицы:

**Customer Details Table**

| ID | Name |
|----|------|

**Invoices Table**

| Invoice No. | Customer_ID | Invoice Date |
|-------------|-------------|--------------|

**Items Table**

| Invoice No. | Item No. | Description | Quantity | Unit Price |
|-------------|----------|-------------|----------|------------|

Теперь каждая таблица отвечает за свою сущность.

### Вторая нормальная форма (2NF)

**Правило:** каждый неключевой столбец должен зависеть от всего составного ключа.

В примере таблица `Items` уже удовлетворяет 2NF, так как `Description` и `Unit Price` зависят от всего ключа `(Invoice No., Item No.)`.

### Третья нормальная форма (3NF)

**Правило:** не должно быть транзитивных зависимостей. Неключевые столбцы должны зависеть только от первичного ключа.

В нашем случае таблица `Invoices` уточняется так:

**Updated Invoices Table**  

| Invoice No. | Customer_ID | Invoice Date |
|-------------|-------------|--------------|

Здесь `Customer_ID` — единственный атрибут, связанный с клиентом.

## Практические последствия

- Более высокие нормальные формы повышают целостность данных, но могут усложнять работу с ними.
- Нужно учитывать специфику приложения при выборе целевой нормальной формы.

## Применение в реальном мире

- Большинство баз данных стремится хотя бы к 3NF.
- Для задач, где важна полная целостность данных, используются 4NF и выше.

## Пример SQL реализации (3NF)

Создание таблицы клиентов:

```sql
CREATE TABLE Customers (  
  ID INT PRIMARY KEY,  
  Name VARCHAR(50)  
);

--Создание таблицы счетов:

CREATE TABLE Invoices (  
  InvoiceNo INT PRIMARY KEY,  
  Customer_ID INT,  
  InvoiceDate DATE,  
  FOREIGN KEY (Customer_ID) REFERENCES Customers(ID)  
);

--Создание таблицы товаров:

CREATE TABLE Items (  
  InvoiceNo INT,  
  ItemNo INT,  
  Description VARCHAR(100),  
  Quantity INT,  
  UnitPrice DECIMAL(10,2),  
  PRIMARY KEY (InvoiceNo, ItemNo),  
  FOREIGN KEY (InvoiceNo) REFERENCES Invoices(InvoiceNo)  
);
```

Эта структура в 3NF разделяет клиентов, счета и товары на отдельные таблицы, что обеспечивает целостность данных и удобство при работе.

# 10. Что такое денормализация и когда её используют?

**Денормализация** — это процесс оптимизации производительности базы данных за счёт уменьшения числа соединений (JOIN) и ускорения выборок, путём преднамеренного добавления избыточности данных.  
Это противоположный подход нормализации: мы жертвуем частью целостности ради скорости.

## Основные техники денормализации

1. **Уплощение связей (Flattening Relationships)**
  - Объединение связанных таблиц для минимизации числа JOIN.
  - Пример: объединение таблиц `Order` и `Product`, чтобы убрать связь многие-ко-многим.

2. **Агрегация данных (Aggregating Data)**
  - Предварительный расчёт значений для снижения нагрузки при запросах.
  - Пример: добавление колонки `Sales_Total` в таблицу `Order`.

3. **Добавление избыточных данных (Adding Redundant Data)**
  - Дублирование информации для уменьшения числа соединений.
  - Пример: таблицы `Customer` и `Sales` обе содержат поле `Country`, хотя оно связано через `Customer`.

## Типовые сценарии применения

- **Отчёты и аналитика (Reporting and Analytics)**
  - Отчёты часто требуют соединений большого числа таблиц.
  - Денормализация упрощает структуру и ускоряет генерацию отчётов.

- **Высоконагруженные транзакционные системы (High-Volume Transaction Systems)**
  - Если допустима кратковременная несогласованность данных, денормализация ускоряет операции.
  - Пример: в e-commerce допускается небольшая задержка обновления данных о продажах ради более быстрого оформления заказов.

- **Системы с преобладанием чтения (Read-Mostly Applications)**
  - Там, где много операций чтения и мало записи.

- **Системы с интенсивным поиском и запросами (Search- and Query-Intensive Applications)**
  - Поисковые движки часто хранят данные в денормализованной форме для ускорения поиска.

- **Распределённые системы (Partitioning Data)**
  - В NoSQL или Hadoop данные часто хранятся с избыточностью для ускорения доступа на разных узлах.

## Соображения и компромиссы

- **Производительность vs. согласованность**
  - Денормализация ускоряет запросы, но снижает консистентность данных.

- **Сложность обслуживания (Maintenance Challenges)**
  - Избыточные данные нужно синхронизировать и обновлять.

- **Простота эксплуатации (Operational Simplicity)**
  - Иногда простая денормализованная структура удобнее, чем строгая нормализация.

- **Гибкость запросов (Query Flexibility)**
  - Нормализованные данные проще адаптировать под новые запросы и изменения схемы, а денормализованные структуры требуют дополнительных усилий для модификаций.

## Итог

Денормализация используется, когда **важнее скорость доступа и упрощение запросов**, чем строгая целостность данных.  
Обычно она применяется:
- в аналитических системах,
- при очень больших объёмах данных,
- в поисковых движках,
- в e-commerce для ускорения отклика.

# 11. Что такое индексы и как они улучшают производительность запросов?

**Индекс** — это дополнительная структура данных в СУБД, которая хранит значения столбца (или столбцов) в отсортированном/оптимизированном для поиска виде вместе с указателями на соответствующие строки таблицы.

**Аналогия:**
- Без индекса: ищешь слово в книге, перелистывая каждую страницу (полный перебор, table scan).
- С индексом: смотришь в алфавитный указатель и сразу находишь нужную страницу.

---

## Основные виды индексов

### Clustered Index (кластерный)
1. **Что делает:** задаёт физический порядок хранения строк в таблице.
2. **Ограничение:** только один на таблицу.
3. **Пример:** если сделать `PRIMARY KEY order_id` (например, в SQL Server), по умолчанию это будет clustered-индекс — строки реально будут расположены по `order_id`.
4. **Плюс:** быстрый поиск и сортировка по ключу.
5. **Минус:** при вставке значений «не в конец» строки нужно переставлять → может быть медленно.

### Non-Clustered Index (некластерный)
- **Что делает:** хранит копию ключей + указатель на место в таблице (Row ID или кластерный ключ).
- **Сколько можно:** хоть десятки на одну таблицу.
- **Пример:**

```sql
  CREATE INDEX idx_orders_customer  
  ON orders(customer_id);
```

- **Плюс:** быстро искать по неосновным полям.
- **Минус:** после нахождения ключа СУБД всё равно идёт в таблицу за остальными полями (lookup).

### Covering Index (покрывающий)
- **Что делает:** содержит все поля, нужные для конкретного запроса — ключи и INCLUDE-колонки.
- **Зачем:** чтобы не ходить в таблицу — всё читается из индекса.
- **Пример:**
```sql
CREATE INDEX idx_orders_cover  
ON orders(customer_id, order_date)  
INCLUDE(total_amount);
```
Запрос:
```sql
SELECT customer_id, order_date, total_amount  
FROM orders  
WHERE customer_id = 101;
```
может выполниться полностью из индекса.

### Unique Index
- **Назначение:** обеспечивает уникальность значений.
- **Где появляется:** создаётся автоматически при `PRIMARY KEY` и `UNIQUE` ограничениях.

## Как индекс устроен внутри

- Чаще всего используется **B-tree**: в узлах хранятся диапазоны значений и ссылки; поиск — `O(log N)` (а не `O(N)`).
- Для полнотекстовых/геоданных могут применяться другие структуры: **hash**, **GiST**, **R-tree**.

## Когда индекс помогает

- Условие в `WHERE` по колонке с индексом, выбирающее **малую долю строк**.
- `JOIN` по индексированным колонкам.
- `ORDER BY` / `GROUP BY` по индексируемым столбцам.
- Частые точечные (`=`) и диапазонные (`BETWEEN`, `>`, `<`) запросы.

## Когда индекс не помогает

- Очень маленькая таблица — полный скан быстрее.
- Запросы, которые выбирают **>20–30%** строк — чтение всей таблицы может быть выгоднее.
- Условия с функциями/выражениями на колонке (индекс не используется):

```sql
    WHERE YEAR(order_date) = 2024    ← индекс по `order_date` не применится
```
- Несeлeктивные условия (например, `WHERE gender = 'M'`, если 90% значений — `'M'`).

---

## Минусы индексов

- **Память:** занимают место на диске.
- **Запись:** замедляют `INSERT/UPDATE/DELETE`, потому что индексы тоже нужно обновлять.
- **Поддержка:** при изменении структуры таблицы индексы нужно перестраивать.

---

## Как проверить, используется ли индекс

**PostgreSQL (текст SQL):**

```sql
  EXPLAIN ANALYZE  
  SELECT *
  FROM orders  
  WHERE customer_id = 123;
```

Смотри, есть ли в плане **Index Scan** (PostgreSQL) или **Index Seek**/**Index Scan** (SQL Server).
- *Index Seek* — быстрый адресный поиск по дереву.
- *Index Scan* — последовательное чтение индекса целиком (лучше, чем table scan, но хуже seek).

## Практический кейс

**Проблема:** в отчёте Power BI запрос

```sql
  SELECT customer_id, SUM(amount)  
  FROM orders  
  WHERE order_date >= '2024-01-01'  
  GROUP BY customer_id;
```

работал ~2 минуты.

**Решение:** создали покрывающий индекс
```sql
CREATE INDEX idx_orders_perf  
ON orders(order_date, customer_id)  
INCLUDE(amount);
```

— время выполнения сократилось до ~5 секунд.

### 12. Что такое PL/SQL?

**a.** PL/SQL (Procedural Language/SQL) — это процедурное расширение Oracle для SQL,  
которое позволяет комбинировать SQL-операторы с возможностями процедурного программирования.

**b. Основные свойства:**
1. **Блочная структура** — код организован в декларативные, исполняемые и обработчики исключений.
2. **Интеграция с SQL** — позволяет встраивать DML-операторы и SELECT-запросы внутрь процедурного кода.
3. **Переменные и типы данных** — поддержка SQL-типов данных и возможность объявления переменных, констант и курсоров.
4. **Управляющие структуры** — поддержка `IF-THEN-ELSE`, `CASE` и циклов (`FOR`, `WHILE`, `LOOP`).
5. **Обработка исключений** — встроенный механизм обработки ошибок через блоки `EXCEPTION`.
6. **Модульность** — поддержка процедур, функций, пакетов и триггеров.
7. **Производительность** — снижение сетевого трафика за счёт выполнения логики непосредственно в базе данных.

**Пример:**
```sql
  DECLARE
  v_total NUMBER;
  BEGIN
    SELECT COUNT(*) INTO v_total FROM employees;
    DBMS_OUTPUT.PUT_LINE(’Total employees: ’ || v_total);
  EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE(‘Error occurred’);
  END;
```
**Ограничения PL/SQL:**
1. **Сложность сопровождения** — чрезмерное размещение бизнес-логики в БД усложняет отладку и тестирование.
2. **Ограниченная повторная используемость** — код PL/SQL нельзя напрямую использовать во внешних приложениях, написанных на других языках.
3. **Зависимость от версии** — некоторые функции доступны только в новых версиях Oracle.
4. **Потенциальная нагрузка на БД** — перенос тяжёлой логики в PL/SQL может перегрузить сервер вместо распределения нагрузки на уровень приложений.
5. **Необходимость специализированных навыков** — не все разработчики владеют PL/SQL, что может ограничить гибкость команды.

**Вывод:**  
PL/SQL лучше всего использовать выборочно, сочетая логику на стороне базы данных с обработкой на стороне приложений.

### 13. Какая разница между процедурным и декларативным подходом в SQL?

**Declarative SQL** — фокусируется на том, *какой результат* нужен, оставляя *как* его получить на усмотрение СУБД.
  Например, простой оператор `SELECT` указывает требуемые данные, а СУБД сама определяет лучший план выполнения. Декларативный SQL лаконичен и оптимизируется базой данных, но предоставляет мало контроля над порядком выполнения.

**Procedural SQL** — объединяет SQL с программными конструкциями для явного указания, *как* выполнять операции.
В PL/SQL, например, можно использовать циклы, условия и обработку ошибок для реализации сложной бизнес-логики.
Такой подход даёт больше контроля и гибкости, но может быть многословным и сложнее в сопровождении.

### 14. Объясните свойства ACID в контексте баз данных

Свойства **ACID** описывают основные гарантии, которые должна обеспечивать система управления базами данных (СУБД) при выполнении транзакций. Они включают:

1. **Atomicity (Атомарность)**
  - Транзакция рассматривается как единое целое: либо выполняется полностью, либо не выполняется вовсе.
  - Если во время выполнения возникает ошибка, все изменения откатываются (rollback).

2. **Consistency (Согласованность)**
  - Транзакция должна переводить базу данных из одного согласованного состояния в другое.
  - Все правила, ограничения и связи данных (constraints, triggers) сохраняются.

3. **Isolation (Изолированность)**
  - Одновременное выполнение транзакций не должно приводить к конфликтам.
  - Результат работы параллельных транзакций эквивалентен их последовательному выполнению (serializability).

4. **Durability (Надёжность/Долговечность)**
  - После фиксации (commit) результат транзакции сохраняется в базе данных даже при сбоях системы или отключении питания.

**Пример:**  
Если пользователь переводит деньги между счетами:
- Атомарность гарантирует, что деньги спишутся с одного счёта и зачислятся на другой, либо операция не произойдёт вообще.
- Согласованность гарантирует, что сумма на обоих счетах будет соответствовать правилам.
- Изолированность гарантирует, что параллельные переводы не «перепутают» данные.
- Надёжность гарантирует, что после успешного перевода данные не потеряются.  

### 15. Объясните логическую архитектуру PostgreSQL

**a.** Логическая архитектура PostgreSQL определяет, как данные организованы и как к ним осуществляется доступ на концептуальном уровне.

**Основные компоненты:**
1. **Cluster** — коллекция баз данных, управляемых одним экземпляром PostgreSQL.
2. **Database** — изолированный контейнер для схем, таблиц и ролей.
3. **Schema** — пространство имён, которое группирует объекты базы данных и предотвращает конфликты имён.
4. **Table** — основная структура хранения данных в строках и столбцах.
5. **Index** — ускоряет выполнение запросов за счёт быстрого поиска.
6. **View** — логическое представление результата запроса (может быть обычным или материализованным).
7. **Role/User** — управляют доступом и правами пользователей.

**b. Как работает выполнение запроса:**
- PostgreSQL проверяет права доступа.
- Разбирает (парсит) запрос.
- Генерирует план выполнения.
- Извлекает данные из соответствующих логических объектов (таблиц, представлений и индексов) без прямого доступа к физическим файлам.  

![DB LOGICAL SCHEMA](../images/db-logical-schema.png)

### 16. Опиши физическую структуру PostgreSQL

Физическая архитектура PostgreSQL описывает, как база данных организована на уровне файловой системы и как фоновые процессы управляют хранением, извлечением и восстановлением данных. Она состоит из **файлов данных, конфигурационных файлов, фоновых процессов, структур памяти и механизмов журналирования транзакций**.

#### Структура файловой системы
1. **Data Directory (PGDATA)** — корневая папка, содержащая все файлы базы данных.
2. **base/** — хранит подкаталоги для каждой базы данных в кластере с отдельными файлами для таблиц и индексов.
3. **global/** — хранит данные уровня кластера (например, роли и определения табличных пространств).
4. **pg_wal/** — содержит WAL-сегменты (Write-Ahead Log), фиксирующие все изменения до их применения к файлам данных.
5. **pg_tblspc/** — символьные ссылки на табличные пространства, созданные пользователем вне директории по умолчанию.
6. **pg_stat/** и **pg_stat_tmp/** — хранят собранную статистику, используемую планировщиком запросов.

#### Фоновые процессы
PostgreSQL использует модель *process-per-connection* (процесс на подключение). Основные фоновые процессы:

- **Postmaster** — главный управляющий процесс, запускает и управляет остальными процессами сервера.
- **Backend Process** — выполняет SQL-запросы для конкретного клиента.
- **WAL Writer** — записывает изменения транзакций в WAL для обеспечения надёжности.
- **Background Writer** — сбрасывает изменённые ("грязные") страницы из буфера в диск.
- **Checkpointer** — периодически сбрасывает все страницы на диск, создавая согласованную точку восстановления (checkpoint).
- **Autovacuum Launcher & Workers** — удаляют "мертвые" записи и поддерживают производительность.
- **Archiver** — переносит завершённые WAL-сегменты в архив (для high-availability и резервного копирования).

#### Write-Ahead Logging (WAL)
1. Все изменения сначала записываются в WAL, а затем в файлы данных.
2. Обеспечивает **надёжность (durability)** и возможность восстановления после сбоев, а также репликацию.
3. WAL используется для **point-in-time recovery** и **streaming replication**.

#### Структуры памяти
1. **Shared Buffers** — основной кэш таблиц и индексов, общий для всех подключений.
2. **WAL Buffers** — временное хранилище для записей WAL перед их сбросом на диск.
3. **Work Memory** — выделяется для выполнения операций запроса (сортировки, соединения и т.д.).
4. **Maintenance Work Memory** — используется для служебных задач (vacuum, создание индексов).

#### Поток данных (Data Flow)
1. Клиент отправляет SQL-запрос.
2. Backend-процесс парсит и планирует запрос.
3. Запрос выполняется и данные читаются из Shared Buffers (или с диска, если не кэшированы).
4. Обновления записываются в WAL.
5. Background Writer и Checkpointer сбрасывают данные на диск.

### 17. Объясните MVCC в PostgreSQL

MVCC (Multi-Version Concurrency Control) — механизм, позволяющий нескольким транзакциям одновременно читать и изменять данные без взаимной блокировки, при этом сохраняя изоляцию транзакций.  
Вместо блокировки строк для читателей PostgreSQL хранит несколько версий строки и использует "снимки транзакций" (snapshots) для определения видимости данных.

#### Как это работает:
1. Каждая строка имеет два скрытых системных столбца:
  - **xmin** — ID транзакции, создавшей строку.
  - **xmax** — ID транзакции, удалившей или изменившей строку.
2. При `UPDATE` PostgreSQL помечает старую версию строки значением `xmax` и вставляет новую строку с новым `xmin`.
3. При `SELECT` база данных возвращает только те версии строк, которые видимы в снимке текущей транзакции.
4. Старые версии становятся «мертвыми кортежами» (dead tuples) и удаляются с помощью `VACUUM` или `Autovacuum`.

#### Преимущества:
1. Читатели не блокируют писателей и наоборот.
2. Улучшается параллельность и производительность в системах с высокой нагрузкой.
3. Бесшовная работа с WAL для обеспечения восстановления после сбоев.

#### Недостатки:
1. Требуется регулярный `VACUUM` для освобождения пространства.
2. Может возникать «разбухание таблиц» (table bloat), если обновлений много, а очистка задерживается.

### 18. Что такое масштабирование на примере PostgreSQL?

Масштабирование — процесс увеличения производительности и пропускной способности PostgreSQL, чтобы обрабатывать больше данных или больше одновременных запросов.


#### Основные подходы:
1. **Vertical Scaling (масштабирование «вверх»)**
  - Увеличение ресурсов одного сервера: CPU, RAM, диски.
  - Простой путь: обновить «железо» или параметры конфигурации PostgreSQL.
  - Пример: увеличить `shared_buffers`, перейти на более мощный сервер.

   **Плюсы:**
  - Легко реализовать.
  - Не требует изменения архитектуры приложения.

   **Минусы:**
  - Есть физический предел (дорого и не бесконечно).
  - Один сервер остаётся «узким горлышком».

2. **Horizontal Scaling (масштабирование «вширь»)**
  - Добавление нескольких серверов для распределения нагрузки.
  - В PostgreSQL реализуется через:
    1. **Read Replicas (Streaming Replication)** — реплики для чтения.
    2. **Logical Replication** — репликация на уровне таблиц/записей, можно частично синхронизировать данные.
    3. **Sharding** — разделение данных по серверам (нет встроенной поддержки; используют Citus, Yugabyte и др.).
    4. **Pgpool-II / PgBouncer** — балансировка нагрузки между серверами.

   **Плюсы:**
  - Нет жёсткого ограничения по мощности.
  - Можно масштабировать чтение и частично запись.

   **Минусы:**
  - Более сложная настройка и поддержка.
  - Консистентность данных сложнее обеспечить.

#### Часто используемые подходы в продакшене:
1. Для **OLTP-систем**: вертикальное масштабирование и read replicas.
2. Для **OLAP-систем**: шардирование, распределённые базы (например, Citus, Greenplum).  

### 19. Что такое шардирование?

Шардирование — метод **горизонтального масштабирования**, при котором база данных делится на несколько частей (**шардов**). Каждый шард хранится на отдельном сервере или экземпляре PostgreSQL.

#### Как работает:
1. Данные распределяются по шардам по ключу шардирования (например, `customer_id`, `region`, диапазон дат).
2. Каждый шард — это полноценная база PostgreSQL, содержащая только часть данных.
3. Логика маршрутизации запросов (какой шард использовать) находится:
  - в приложении,
  - в промежуточном ПО (middleware),
  - или в расширении PostgreSQL (например, **Citus**).

#### Типы шардирования:
1. **Range sharding** — разделение по диапазонам значений.
2. **Hash sharding** — распределение по хэш-функции:
  - обеспечивает равномерное распределение данных по шардам;
  - предотвращает «горячие узлы» (например, для ключей `user_id`).
  - Общая схема:
    1. Выбираем ключ шардирования (`user_id`, `order_id`, `region_id`).
    2. Считаем хэш (например, MD5, SHA-1).
    3. Преобразуем hex-строку хэша в число.
    4. Берём остаток от деления на количество шардов (`% N`).
    5. Получаем номер шарда.
3. **Directory-based sharding** — отдельная таблица-словарь хранит соответствие ключа и шарда.

#### Плюсы:
1. Почти неограниченный рост данных.
2. Возможность параллельной обработки запросов на разных шардах.
3. Распределение нагрузки.

#### Минусы:
1. Сложные запросы, охватывающие несколько шардов.
2. Сложности в транзакциях между шардами.
3. Более сложная инфраструктура и поддержка.  

### 20. Что такое репликация?

Репликация — это процесс **копирования данных** с основного сервера (**primary**) на один или несколько резервных серверов (**standby**) для повышения доступности, производительности и отказоустойчивости.

#### Потоковая репликация (Streaming Replication)
- Использует **WAL (Write-Ahead Log)** для передачи изменений в реальном времени.
- Бывает:
  1. **Асинхронная** — primary не ждёт ответа standby.
    - Плюс: быстрее.
    - Минус: возможна небольшая потеря данных при сбое.
  2. **Синхронная** — primary ждёт подтверждения standby.
    - Плюс: нет потери данных.
    - Минус: выше задержка.

#### Логическая репликация (Logical Replication)
1. Передаёт изменения на уровне строк и таблиц.
2. Можно реплицировать только **определённые таблицы**.
3. Подходит для интеграции с другими системами или частичного копирования данных.

#### Каскадная репликация (Cascading Replication)
- Реплика может сама быть источником данных для других реплик.

#### Плюсы:
1. Высокая доступность.
2. Масштабирование чтения (запросы можно переносить на реплики).
3. Резервное копирование в реальном времени.

#### Минусы:
1. Нет масштабирования записи (реплики — только для чтения).
2. В синхронной репликации — выше задержки.
3. В асинхронной репликации — риск потери последних транзакций.

### 21. Что такое партиционирование в SQL?

Партиционирование — это разбиение одной большой таблицы на более мелкие **партиции** в рамках **одной базы данных и одного сервера**.  
Для пользователя это выглядит как одна логическая таблица, но физически — это набор отдельных таблиц.

#### Типы партиционирования в PostgreSQL:
1. **Range** — разделение по диапазонам значений (например, по датам).
2. **List** — разделение по спискам значений (например, по регионам).
3. **Hash** — распределение по хэш-функции.

#### Плюсы:
1. Повышение производительности за счёт **partition pruning** (читается только нужная партиция).
2. Удобство обслуживания (можно удалять или архивировать старые партиции).
3. Подходит для работы с большими таблицами и временными рядами.

#### Минусы:
1. Все партиции хранятся на **одном сервере** → масштабирование ограничено его ресурсами.
2. Настройка и поддержка могут быть сложнее, чем у обычных таблиц.

#### Ключевое отличие от других подходов:
1. **Шардирование** — масштабирование «вширь» (данные на разных серверах).
2. **Партиционирование** — оптимизация внутри одного сервера.
3. **Репликация** — дублирование данных для отказоустойчивости и масштабирования чтения.  

### 22. Что такое триггер?

Триггер — это объект базы данных, который автоматически выполняет заданный блок кода (обычно на языке PL/pgSQL) **при наступлении определённого события** в таблице или представлении.  
Он «срабатывает» без явного вызова из приложения — при вставке, обновлении, удалении или других событиях.

#### Виды триггеров по моменту выполнения:
1. **BEFORE** — до выполнения операции (можно изменить данные или отменить действие).
2. **AFTER** — после выполнения операции (можно записать в журнал, обновить другие таблицы).
3. **INSTEAD OF** — используется для представлений, заменяя операцию на свою.

#### Типы событий для триггеров:
- **INSERT** — вставка строки.
- **UPDATE** — изменение строки.
- **DELETE** — удаление строки.
- **TRUNCATE** — очистка таблицы.

#### Пример в PostgreSQL
```sql
– Функция, которую будет вызывать триггер
CREATE OR REPLACE FUNCTION log_update()
RETURNS trigger AS $$
BEGIN
  INSERT INTO audit_log(table_name, operation, changed_at)
  VALUES (TG_TABLE_NAME, TG_OP, NOW());
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

– Создаём триггер
CREATE TRIGGER trg_log_update
AFTER UPDATE ON employees
FOR EACH ROW
EXECUTE FUNCTION log_update();
```

В этом примере:
- **TG_TABLE_NAME** — системная переменная с именем таблицы.
- **TG_OP** — тип операции (INSERT, UPDATE, DELETE).

#### Плюсы триггеров:
1. Автоматизация задач (логирование, валидация, каскадные изменения).
2. Централизация логики на уровне БД.
3. Гарантия, что правило выполнится независимо от приложения.

#### Минусы триггеров:
1. Скрытая логика (труднее отлаживать).
2. Может замедлять операции при сложной логике.
3. Риск рекурсивного вызова триггеров.  

### 23. В чем разница между триггером и процедурой/функцией?

#### a. Функция или процедура
- **Функция (FUNCTION)** — объект, который выполняет код и возвращает значение.
  - Может использоваться в запросах, выражениях, других функциях.
  - В PostgreSQL может возвращать простое значение или таблицу (`RETURNS TABLE`).
  - Вызывается явно:
    ```
    SELECT my_function(123);
    ```
- **Процедура (PROCEDURE)** — появилась в PostgreSQL 11.
  - Не обязана возвращать значение.
  - Может выполнять транзакционные команды (`COMMIT`, `ROLLBACK`).
  - Вызывается командой:
    ```
    CALL my_procedure(123);
    ```

#### Триггер
  **Триггер (TRIGGER)** — объект, который **не вызывается явно**, а выполняется **автоматически** при наступлении определённого события (`INSERT`, `UPDATE`, `DELETE`, `TRUNCATE`).
  Сам триггер кода не содержит, а **ссылается на функцию**, которая выполняется при срабатывании.
  В PostgreSQL триггерная функция должна возвращать `NEW` или `OLD` (для BEFORE-триггеров), либо `NULL` (если операция должна быть отменена).


#### Ключевые отличия

| Характеристика     | Функция / Процедура                           | Триггер                                       |
|--------------------|-----------------------------------------------|-----------------------------------------------|
| **Как вызывается** | Явно (`SELECT` или `CALL`)                   | Автоматически при событии                     |
| **Возврат значения** | Функция — да, процедура — нет               | Зависит от типа (`NEW` / `OLD`)               |
| **Привязка**       | Не привязаны к таблице                       | Привязаны к конкретной таблице или `VIEW`     |
| **Использование**  | Вычисления, бизнес-логика, операции с данными | Логирование, валидация, каскадные изменения   |
| **Видимость логики** | Очевидна в коде приложения                  | Может быть скрыта внутри БД                   |

### 25. Что такое представления (views) и каковы их преимущества? Как они могут использоваться в контексте OLAP-систем?

**View** в SQL — это виртуальная таблица, основанная на результате заранее определённого запроса.
  Данные в view не хранятся (кроме **материализованных представлений**, где данные сохраняются).
  Представления могут объединять таблицы, фильтровать строки и выдавать агрегированные результаты.

#### Преимущества представлений
1. **Simplification** — упрощают работу, скрывая сложные запросы за одним объектом.
2. **Security** — можно выдавать доступ только к нужным колонкам/строкам без раскрытия всей таблицы.
3. **Reusability** — бизнес-логику можно переиспользовать в разных приложениях.
4. **Abstraction** — скрывают приложения от изменений в схеме базы данных.
5. **Aggregation** — позволяют создавать заранее агрегированные результаты для аналитики.

#### Использование в OLAP-системах
1. Представление агрегированных показателей (например, продажи по регионам и месяцам).
2. Работа в качестве **семантического слоя** между хранилищем данных и BI-инструментами.
3. Использование **материализованных представлений** для хранения предагрегированных данных и ускорения отчётов.
4. Упрощение многомерных запросов (инкапсуляция сложных `JOIN` и фильтров).

#### d. Пример
```sql
  CREATE VIEW sales_summary AS
  SELECT region, date_trunc(‘month’, sale_date) AS month, SUM(amount) AS total_sales
  FROM sales
  GROUP BY region, date_trunc(‘month’, sale_date);
```
> Такое представление можно напрямую использовать в BI-инструменте для получения ежемесячных сводных данных без повторного пересчёта агрегатов.  