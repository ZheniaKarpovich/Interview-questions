## [Main title](../README.md)
### [Interview questions](full.md)
# DB/SQL

# 1. Что такое SQL и для чего он используется?

**SQL** (Structured Query Language — язык структурированных запросов) — это предметно-ориентированный декларативный язык программирования, предназначенный для работы с реляционными базами данных.  
Он является основным языком для выполнения таких задач, как:
- извлечение данных,
- изменение данных,
- администрирование базы данных.

## Основные компоненты SQL

- **DDL (Data Definition Language)** — язык определения данных. Используется для описания и изменения структуры базы данных.
- **DML (Data Manipulation Language)** — язык манипулирования данными. Отвечает за добавление, изменение и удаление данных в базе.
- **DCL (Data Control Language)** — язык управления доступом. Используется для управления правами и разрешениями в базе данных.
- **TCL (Transaction Control Language)** — язык управления транзакциями. Регулирует работу с транзакциями (например, фиксация изменений `COMMIT` или их откат `ROLLBACK`). 

# 2. Разница между SQL и NoSQL базами данных

SQL и NoSQL базы данных предлагают разные парадигмы, каждая из которых предназначена для определённых типов данных и способов их обработки.

## Основные различия

- **SQL**: Предназначены в первую очередь для структурированных (и частично полуструктурированных) данных, которые соответствуют заранее определённой схеме.
- **NoSQL**: Подходят для неструктурированных или полуструктурированных данных, которые постепенно эволюционируют, обеспечивая гибкость в схемах.

- **SQL**: Использует язык SQL (Structured Query Language) для модификации и извлечения данных.
- **NoSQL**: Предоставляет различные API (например, интерфейсы для документо-ориентированных и ключ-значение хранилищ); использование структурированных языков запросов зависит от конкретной реализации.

- **SQL**: Обычно гарантирует соответствие принципам **ACID** (атомарность, согласованность, изоляция, долговечность), что обеспечивает целостность данных.
- **NoSQL**: Часто оптимизированы для высокой производительности и горизонтального масштабирования, иногда в ущерб строгой согласованности.

## Основные типы NoSQL баз данных

- **Документо-ориентированные хранилища**
    - Примеры: MongoDB, Couchbase
    - Особенности: каждая запись — это самостоятельный документ (обычно JSON). Связи реализуются через вложенные документы или ссылки.
    - Пример: пользователь и его посты в блоге могут храниться в одном документе или быть связаны через ссылки.

- **Ключ-значение хранилища**
    - Примеры: Redis, Amazon DynamoDB
    - Особенности: данные хранятся в виде уникальных ключей и значений. Нет обязательной схемы.
    - Пример: товары в корзине интернет-магазина, связанные с ID пользователя.

- **Широкостолбцовые базы (Column Families)**
    - Примеры: Apache Cassandra, HBase
    - Особенности: данные группируются в семейства столбцов, аналогичные таблицам, но с гибкой схемой.
    - Пример: профили пользователей, где у одних могут быть уникальные атрибуты.

- **Графовые базы данных**
    - Примеры: Neo4j, JanusGraph
    - Особенности: оптимизированы для данных со сложными связями. Сущности представлены как узлы, а связи — как рёбра.
    - Пример: социальные сети с управлением связями «дружбы».

## Отличия в моделировании данных

- **SQL**: нормализация для минимизации избыточности и аномалий при обновлении.
- **NoSQL**: денормализация — данные упаковываются вместе, чтобы сократить количество запросов.

## Генерация ID

- **SQL**: часто используется автоинкрементное уникальное ID.
- **NoSQL**: уникальные идентификаторы могут генерироваться внешними системами или на уровне документа.

## Работа с отношениями данных

- **SQL**: связи реализуются через ключи (первичные и внешние).
- **NoSQL**: связи могут быть реализованы через вложенные документы, ссылки или графовые структуры.

## Поддержка транзакций

- **SQL**: транзакции — стандартная часть функционала.
- **NoSQL**: поддержка транзакций зависит от реализации.

## Уровни согласованности данных

- **SQL**: обеспечивает строгую согласованность.
- **NoSQL**: предлагает разные модели — от строгой до eventual consistency (согласованности в конечном счёте).

## Масштабируемость

- **SQL**: вертикальная (мощность одного сервера увеличивается).
- **NoSQL**: горизонтальная (распределение нагрузки на множество серверов).

## Гибкость данных

- **SQL**: строгая схема, трудно адаптировать к меняющимся структурам данных.
- **NoSQL**: поддерживает динамическое обновление схемы, что даёт высокую гибкость.

## Целостность и валидация данных

- **SQL**: целостность обеспечивается ограничениями и строгими типами данных.
- **NoSQL**: больше полагается на приложение для управления целостностью и проверкой данных.  

# 3. Какие операции можно выполнять с помощью SQL, для чего они нужны и их порядок выполнения?

В SQL команды делятся на несколько категорий.

## DDL (Data Definition Language) — язык определения данных
Используется для описания и изменения структуры объектов базы данных.

- **CREATE** — создание объектов (таблицы, представления, схемы и т.д.)
- **ALTER** — изменение структуры объектов
- **DROP** — удаление объектов
- **TRUNCATE** — очистка таблицы (быстрое удаление всех строк без возможности отката)
- **RENAME** — переименование объекта

> ⚡ Особенность: DDL-команды фиксируются автоматически (**auto-commit**) и не могут быть откатаны.

---

## DML (Data Manipulation Language) — язык манипуляции данными
Используется для работы с данными в таблицах.

- **SELECT** — чтение данных
- **INSERT** — добавление строк
- **UPDATE** — изменение строк
- **DELETE** — удаление строк

> ⚡ Особенность: DML-команды поддерживают транзакции и могут быть отменены (**ROLLBACK**).

### Основные операции в SELECT-запросе
- **SELECT** — определяет столбцы или выражения для вывода
- **FROM** — задаёт источники данных (таблицы, представления)
- **JOIN** — объединяет данные из разных таблиц
- **WHERE** — фильтрует строки до группировки
- **GROUP BY** — группирует строки в агрегаты
- **HAVING** — фильтрует сгруппированные результаты
- **ORDER BY** — сортирует вывод
- **LIMIT** — ограничивает количество возвращаемых строк

#### Логический порядок выполнения запроса
Хотя пишем мы команды в одном порядке, выполняются они так: FROM → JOIN → WHERE → GROUP BY → HAVING → SELECT → ORDER BY → LIMIT

> Это объясняет, например, почему нельзя использовать алиасы из `SELECT` в `WHERE`.

---

## DCL (Data Control Language) — язык управления доступом
Используется для работы с правами пользователей.

- **GRANT** — выдаёт права
- **REVOKE** — отзывает права

---

## TCL (Transaction Control Language) — язык управления транзакциями
Регулирует выполнение транзакций.

- **COMMIT** — зафиксировать изменения
- **ROLLBACK** — откатить изменения
- **SAVEPOINT** — установить точку сохранения в транзакции

---

📌 **Краткий итог:**
- DDL управляет структурой базы (CREATE/ALTER/DROP).
- DML управляет данными (SELECT/INSERT/UPDATE/DELETE).
- DCL управляет доступом (GRANT/REVOKE).
- TCL управляет транзакциями (COMMIT/ROLLBACK/SAVEPOINT).
- Логический порядок выполнения SELECT отличается от синтаксического и это важно для правильного понимания запросов.  

# 4. Какие типы JOIN-ов существуют и в чем их отличия ?

# JOIN в SQL и их типы

**JOIN** в SQL используется для объединения строк из двух или более таблиц на основе связанного столбца (обычно ключа).  
Понимание типов соединений важно для правильной работы с нормализованными данными и предотвращения случайных декартовых произведений.

## Основные типы JOIN

- **INNER JOIN** — возвращает только совпадающие строки в обеих таблицах.
- **LEFT JOIN** — возвращает все строки из левой таблицы и совпадения из правой; если совпадений нет, подставляются `NULL`.
- **RIGHT JOIN** — противоположен LEFT JOIN: возвращает все строки из правой таблицы и совпадения из левой.
- **FULL JOIN (FULL OUTER JOIN)** — возвращает все строки из обеих таблиц, подставляя `NULL` там, где нет совпадений.
- **CROSS JOIN** — формирует декартово произведение (каждая строка из первой таблицы соединяется со всеми строками второй).
- **SELF JOIN** — соединение таблицы с самой собой (часто используется для иерархий, например «сотрудник → менеджер»).

## Визуализация типов JOIN

![SQL JOINS](../images/sql-joins.png)

# 5. Что такое первичный ключ (Primary Key) в базе данных?

**Первичный ключ** — это столбец или набор столбцов, которые однозначно идентифицируют каждую строку в таблице базы данных.

## Основные свойства:
- Значения **должны быть уникальными**.
- Значения **не могут быть NULL**.
- В таблице может быть **только один первичный ключ**, но он может состоять из нескольких столбцов (**составной ключ**).
- Большинство СУБД автоматически создают индекс для первичного ключа, чтобы ускорить поиск.

## Пример

```sql
CREATE TABLE employees (
    employee_id INT PRIMARY KEY,
    name VARCHAR(100)
);
```
### Что делает этот код?

1. Создаёт таблицу `employees`.
2. Определяет столбец `employee_id` как **PRIMARY KEY**.
3. Обеспечивает уникальность каждого значения `employee_id`.
4. Запрещает использование `NULL` для `employee_id`.
5. Даёт возможность использовать `employee_id` как ссылку (внешний ключ) в других таблицах.
6. Автоматически создаёт индекс по `employee_id` для ускорения поиска. 

# 6. Что такое внешний ключ (Foreign Key) и как он используется?

**Внешний ключ (FOREIGN KEY)** — это столбец или набор столбцов в одной таблице, которые ссылаются на первичный ключ в другой таблице.

## Основные свойства:
- Внешний ключ всегда указывает на **PRIMARY KEY** или **UNIQUE ключ** в родительской таблице.
- Его назначение — обеспечивать **ссылочную целостность**, то есть согласованность связей между таблицами.
- Он не допускает вставку значений, которых нет в родительской таблице.
- Может определять действия при изменении или удалении строки в родительской таблице:
  - `ON DELETE CASCADE` — удаляет связанные записи.
  - `ON DELETE SET NULL` — устанавливает значение `NULL` во внешнем ключе.
  - `RESTRICT` — запрещает удаление/обновление, если есть связанные записи.

## Пример

```sql
CREATE TABLE employees (
    employee_id INT PRIMARY KEY,
    department_id INT,
    FOREIGN KEY (department_id) REFERENCES departments(department_id)
);
```

# 7. В чем разница между PRIMARY KEY и UNIQUE ключом?

## PRIMARY KEY
- Однозначно идентифицирует каждую строку в таблице.
- Может состоять из **одного или нескольких столбцов** (составной ключ).
- В таблице может быть **только один PRIMARY KEY**.
- Значения **не могут быть NULL**.
- При создании автоматически создаётся индекс.

## UNIQUE ключ
- Гарантирует, что значения в столбце (или наборе столбцов) будут уникальны.
- В таблице может быть **несколько UNIQUE ключей**.
- В отличие от PRIMARY KEY, допускает **одно значение NULL** (поведение может отличаться в разных СУБД).
- Тоже создаёт уникальный индекс, но не обязательно является «основным идентификатором» таблицы.

## Кратко
- `PRIMARY KEY` — главный идентификатор строки, обязателен для таблицы и всегда **NOT NULL + UNIQUE**.
- `UNIQUE` — дополнительное ограничение для предотвращения дубликатов в других столбцах, но допускает `NULL` (в большинстве СУБД).

## Пример

```sql
CREATE TABLE users (
    user_id INT PRIMARY KEY,
    email VARCHAR(255) UNIQUE,
    phone VARCHAR(20) UNIQUE
);
```

# 8. Какие виды связей между таблицами существуют и как они реализуются?

В реляционных базах данных существуют три основных типа связей между таблицами: **1:1 (один к одному)**, **1:M (один ко многим)** и **M:N (многие ко многим)**.

---

## 1. Связь 1:1 (One-to-One)

**Определение:** каждой записи в первой таблице соответствует не более одной записи во второй, и наоборот.

**Пример:**
- Таблица `users` — основная информация о пользователях.
- Таблица `user_profiles` — дополнительная информация (например, паспортные данные).

**Реализация:**  
Во второй таблице (`user_profiles`) создаётся внешний ключ (`FOREIGN KEY`), который также является `PRIMARY KEY`.  
Это гарантирует, что у каждого пользователя будет не более одного профиля.

```sql
CREATE TABLE users (  
  user_id INT PRIMARY KEY,  
  name VARCHAR(100)  
);

CREATE TABLE user_profiles (  
  user_id INT PRIMARY KEY,  
  address VARCHAR(200),  
  FOREIGN KEY (user_id) REFERENCES users(user_id)  
);
```

## 2. Связь 1:M (One-to-Many)

**Определение:** каждой записи в первой таблице может соответствовать много записей во второй, но каждая запись во второй таблице относится только к одной записи в первой.

**Пример:**
- Таблица `departments` — список отделов.
- Таблица `employees` — список сотрудников.

**Реализация:**  
Во второй таблице (`employees`) создаётся внешний ключ, который ссылается на первичный ключ первой таблицы (`departments`).

```sql
CREATE TABLE departments (  
  department_id INT PRIMARY KEY,  
  department_name VARCHAR(100)  
);

CREATE TABLE employees (  
  employee_id INT PRIMARY KEY,  
  name VARCHAR(100),  
  department_id INT,  
  FOREIGN KEY (department_id) REFERENCES departments(department_id)  
);
```

## 3. Связь M:N (Many-to-Many)

**Определение:** каждой записи в первой таблице может соответствовать много записей во второй, и наоборот.

**Пример:**
- Таблица `students` — студенты.
- Таблица `courses` — курсы.
- Один студент может посещать много курсов, и один курс может посещаться многими студентами.

**Реализация:**  
Создаётся третья таблица (промежуточная или связующая), которая хранит пары ключей.

```sql
CREATE TABLE students (  
  student_id INT PRIMARY KEY,  
  name VARCHAR(100)  
);

CREATE TABLE courses (  
  course_id INT PRIMARY KEY,  
  course_name VARCHAR(100)  
);

CREATE TABLE student_courses (  
  student_id INT,  
  course_id INT,  
  PRIMARY KEY (student_id, course_id),  
  FOREIGN KEY (student_id) REFERENCES students(student_id),  
  FOREIGN KEY (course_id) REFERENCES courses(course_id)  
);
```

Таблица `student_courses` связывает студентов и курсы, реализуя связь «многие ко многим».

# 9. Что такое нормализация? Объясните с примерами

**Нормализация** — это метод проектирования базы данных, направленный на упорядочение структуры таблиц с целью уменьшения избыточности данных и повышения их целостности.  
Процесс выполняется поэтапно и разделён на несколько нормальных форм (1NF, 2NF, 3NF, BCNF, 4NF), каждая из которых имеет свои правила.

## Пример нормализации (сценарий «Customer Invoices»)

### Ненормализованная таблица (0NF)

| ID | Name | Invoice No. | Invoice Date | Item No. | Description | Quantity | Unit Price |
|----|------|-------------|--------------|----------|-------------|----------|------------|

В таком виде все данные хранятся в одной таблице без структурной логики. Записи содержат и данные о клиенте, и данные о счёте, и данные о товарах. Это приводит к избыточности и аномалиям.

### Первая нормальная форма (1NF)

**Правило:** все ячейки должны быть атомарными (только одно значение). Нужно разделять связанные группы данных.

В примере выделяем отдельные таблицы:

**Customer Details Table**

| ID | Name |
|----|------|

**Invoices Table**

| Invoice No. | Customer_ID | Invoice Date |
|-------------|-------------|--------------|

**Items Table**

| Invoice No. | Item No. | Description | Quantity | Unit Price |
|-------------|----------|-------------|----------|------------|

Теперь каждая таблица отвечает за свою сущность.

### Вторая нормальная форма (2NF)

**Правило:** каждый неключевой столбец должен зависеть от всего составного ключа.

В примере таблица `Items` уже удовлетворяет 2NF, так как `Description` и `Unit Price` зависят от всего ключа `(Invoice No., Item No.)`.

### Третья нормальная форма (3NF)

**Правило:** не должно быть транзитивных зависимостей. Неключевые столбцы должны зависеть только от первичного ключа.

В нашем случае таблица `Invoices` уточняется так:

**Updated Invoices Table**  

| Invoice No. | Customer_ID | Invoice Date |
|-------------|-------------|--------------|

Здесь `Customer_ID` — единственный атрибут, связанный с клиентом.

## Практические последствия

- Более высокие нормальные формы повышают целостность данных, но могут усложнять работу с ними.
- Нужно учитывать специфику приложения при выборе целевой нормальной формы.

## Применение в реальном мире

- Большинство баз данных стремится хотя бы к 3NF.
- Для задач, где важна полная целостность данных, используются 4NF и выше.

## Пример SQL реализации (3NF)

Создание таблицы клиентов:

```sql
CREATE TABLE Customers (  
  ID INT PRIMARY KEY,  
  Name VARCHAR(50)  
);

--Создание таблицы счетов:

CREATE TABLE Invoices (  
  InvoiceNo INT PRIMARY KEY,  
  Customer_ID INT,  
  InvoiceDate DATE,  
  FOREIGN KEY (Customer_ID) REFERENCES Customers(ID)  
);

--Создание таблицы товаров:

CREATE TABLE Items (  
  InvoiceNo INT,  
  ItemNo INT,  
  Description VARCHAR(100),  
  Quantity INT,  
  UnitPrice DECIMAL(10,2),  
  PRIMARY KEY (InvoiceNo, ItemNo),  
  FOREIGN KEY (InvoiceNo) REFERENCES Invoices(InvoiceNo)  
);
```

Эта структура в 3NF разделяет клиентов, счета и товары на отдельные таблицы, что обеспечивает целостность данных и удобство при работе.

# 10. Что такое денормализация и когда её используют?

**Денормализация** — это процесс оптимизации производительности базы данных за счёт уменьшения числа соединений (JOIN) и ускорения выборок, путём преднамеренного добавления избыточности данных.  
Это противоположный подход нормализации: мы жертвуем частью целостности ради скорости.

## Основные техники денормализации

1. **Уплощение связей (Flattening Relationships)**
  - Объединение связанных таблиц для минимизации числа JOIN.
  - Пример: объединение таблиц `Order` и `Product`, чтобы убрать связь многие-ко-многим.

2. **Агрегация данных (Aggregating Data)**
  - Предварительный расчёт значений для снижения нагрузки при запросах.
  - Пример: добавление колонки `Sales_Total` в таблицу `Order`.

3. **Добавление избыточных данных (Adding Redundant Data)**
  - Дублирование информации для уменьшения числа соединений.
  - Пример: таблицы `Customer` и `Sales` обе содержат поле `Country`, хотя оно связано через `Customer`.

## Типовые сценарии применения

- **Отчёты и аналитика (Reporting and Analytics)**
  - Отчёты часто требуют соединений большого числа таблиц.
  - Денормализация упрощает структуру и ускоряет генерацию отчётов.

- **Высоконагруженные транзакционные системы (High-Volume Transaction Systems)**
  - Если допустима кратковременная несогласованность данных, денормализация ускоряет операции.
  - Пример: в e-commerce допускается небольшая задержка обновления данных о продажах ради более быстрого оформления заказов.

- **Системы с преобладанием чтения (Read-Mostly Applications)**
  - Там, где много операций чтения и мало записи.

- **Системы с интенсивным поиском и запросами (Search- and Query-Intensive Applications)**
  - Поисковые движки часто хранят данные в денормализованной форме для ускорения поиска.

- **Распределённые системы (Partitioning Data)**
  - В NoSQL или Hadoop данные часто хранятся с избыточностью для ускорения доступа на разных узлах.

## Соображения и компромиссы

- **Производительность vs. согласованность**
  - Денормализация ускоряет запросы, но снижает консистентность данных.

- **Сложность обслуживания (Maintenance Challenges)**
  - Избыточные данные нужно синхронизировать и обновлять.

- **Простота эксплуатации (Operational Simplicity)**
  - Иногда простая денормализованная структура удобнее, чем строгая нормализация.

- **Гибкость запросов (Query Flexibility)**
  - Нормализованные данные проще адаптировать под новые запросы и изменения схемы, а денормализованные структуры требуют дополнительных усилий для модификаций.

## Итог

Денормализация используется, когда **важнее скорость доступа и упрощение запросов**, чем строгая целостность данных.  
Обычно она применяется:
- в аналитических системах,
- при очень больших объёмах данных,
- в поисковых движках,
- в e-commerce для ускорения отклика.
